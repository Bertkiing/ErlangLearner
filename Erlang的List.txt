%% 参考链接：http://mbooks.me/LYEFGG/starting-out-for-real.html#binary-comprehensions

Erlang的列表介绍：
    对于许多函数式的语言来说，列表是整个语言的基础。Erlang也免不了整个俗。
    列表是非常有用的数据结构，可以解决所有类型的问题。

1.列表可以保存任何类型：数字,原子,元组,列表;
2.列表实现了你狂野的梦想，任何类型都可以放在一个列表中;
3.列表由[]来创建;

%%------------------------%%

Erlang中的字符串
也许,Erlang中最不让人讨厌的东西就是字符串。
其实字符串和列表是完全一样的。

列表的常用操作：
1. ++ 操作符：
    可以将两个列表拼接在一起;
    [1,2,3] ++ [4,5] 结果为 [1,2,3,4,5]
2. -- 操作符:
    可以从列表中删除某些元素;
    [1,2,3] -- [1,2] 结果为 [3];
    [1,2,3] -- [5] 结果为[1,2,3];因为找不到
 要特别注意的地方：
    ++,--操作符 如果有多个++,--出现在一条语句中，这些操作是从右往左执行的。如：
    [1,2,3] --[1,2] --[3] 结果为[3].
    [1,2,3] --[1,2] --[1] 结果为[1,3].
3.内置函数hd(List)提取列表的头;
4.内置函数tl(List)提取列表的尾;

当我们在处理列表的时候,由于你经常从列表头开始,你会想要一个快速保存列表尾的方法,这样你可以
在后续的操作中实用列表尾。
我们也可以使用[Head|Tail] = List. 
Head就是列表头;Tail是列表尾.
我们称“|”操作符为const操作符(构造函数),事实上，所有的列表都是由const操作符和值构成的;
[1,2,3,4].
[1,2,3,4|[]].
[1,2,3|[4]].
[1,2|[3|[4]]].
[1|2|[3|4|[]]]

在[1|[2]]这样的列表称为“不当列表”;
在[1|2]这样的列表称为“正常列表”;
在之前的版本,当我们只用模式匹配[Head|Tail]的时候,不当列表是可以正常工作的，但当我们使用Erlang的常用函数的时候就会失败(即便是length()).
而在erlang 19版本,不当列表也是可以正常使用的.

%%-------------------列表推导式---------------------%%
列表推导式是修改和创建列表的方式。比起其他列表的方式，这种方式会让程序更短更容易理解。
它是基于集合符号；

列表解析一开始可能很难掌握,但是他们很值得你投入时间。
(List comprehensions may be hard to grasp at first,but they're worth the effort.)
列表推导式让代码非常简洁,所以不要犹豫,在你完全明白之前可以不断的尝试！
(They make code cleaner and shorter,so don't hesitate to try and type in the examples until you understand them!)

Erlang中的列表推导式是从一个集合构建另一个集合的方式。
[2*N || N <- [1,2,3,4]] 结果为 [2,4,6,8];

你可以通过添加返回布尔值的操作符来作为列表推导式的约束。
[X || X <- [1,2,3,4,5,6,7,8,9,10], X rem 2 =:= 0]结果为 [2,4,6,8,10];
此处的(X rem 2 =:= 0)就是布尔表达式。

在Erlang中列表推导式总是写作NewList = [Expression || Pattern <- List,Condition1,Condition2,...ConditionN].
其中 Pattern <- List 这部分被称为生成器表达式。我们可以在一个列表推导式中写多个生成器表达式！


为了让列表推导式更加通用一些：
NewList = [Expression || GeneratorExp1，GeneratorExp2,...GeneratorExpN,Condition1,Condition2,...ConditionN].








    注意：内置函数(BIFs)是一些无法用纯Erlang实现的函数,只能用C或者其它来实现的Erlang的语言(80年代Erlang是用Prolog实现的)。
当然这里面也有一些BIF是可以用纯Erlang来实现的,但是因为性能问题，依然选择用C实现。例如,length(List)函数